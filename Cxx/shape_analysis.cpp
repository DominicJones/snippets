/*
Monday: 7:45am - 8:00am
  compute surface centroid
  compute min x & y, and max x & y
  compute max dx and max dy
  check surface centroid is at (min x + dx, min y + dy)
  use g-g theorm to compute surface area, compare it with max(dx,dy)
  

Context
=======

This question is based on a real problem that we had to solve in production. There was a computationally
expensive algorithm implemented for generic polygons; however we have noticed that in the majority of
cases the polygon that we were passing to the algorithm was a rectangle, and for rectangles the
implementation of the algorithm was much faster.

Task
====

Implement a function that determines whether a given `Polygon` represents an axis-aligned rectangle, and
if so, returns a `Rectangle` which is equivalent.

You may assume:

- `Polygon` is a counter-clockwise oriented collection of points. This means the inside of the polygon
   would be on your left if you walked around the boundary following the points in the order provided
- `Polygon`, if not empty, is guaranteed to be cyclic, that is `polygon.front() == polygon.back()`

The `Polygon` may have been generated by other algorithms which suffer numerical instability problems so
your implementation should aim to be robust to degenerate cases. Example degenerate cases which should
be handled include:

- Points lying on the straight edge connecting another pair of points a.k.a. redundant points
- Polygons with points slightly perturbed from exact rectangles should still convert to rectangles

Instructions
============

- Write one or two paragraphs about the chosen approach and document key assumptions you make regarding
  the input and the expected behaviour of your implementation
- Preserve the API of the `fit_into_rectangle` function (so we can easily run it through a test suite)
- Submit your solution as a single .cpp file and provide the compilation command used to build it.
  If you have been asked to submit your solution using codeinterview.io, you can make sure that your
  solution builds and passes the tests by pressing the "Run" button at the bottom of the page
- Please give an approximate time taken to solve the question

*/

constexpr float k_default_epsilon = .0001f;

bool almost_equal(float a, float b, float epsilon = k_default_epsilon) {
    return std::abs(a - b) <= epsilon;
}

struct Point {
    float x;
    float y;
    friend bool operator==(const Point& lhs, const Point& rhs) {
        return lhs.x == rhs.x and lhs.y == rhs.y;
    }
    friend std::ostream& operator<<(std::ostream& out, const Point& point) {
        return out << "(" << point.x << "," << point.y << ")";
    }
};

bool almost_equal(const Point& a, const Point& b, float epsilon = k_default_epsilon) {
    return almost_equal(a.x, b.x, epsilon) and almost_equal(a.y, b.y, epsilon);
}

using Polygon = std::vector<Point>;

struct Rectangle {
    Point bottom_left;
    Point top_right;
    friend std::ostream& operator<<(std::ostream& out, const Rectangle& rectangle) {
        return out << "Rectangle(" << rectangle.bottom_left << "," << rectangle.top_right << ")";
    }
};

bool almost_equal(const Rectangle& a, const Rectangle& b, float epsilon = k_default_epsilon) {
    return almost_equal(a.bottom_left, b.bottom_left) and almost_equal(a.top_right, b.top_right);
}

// TODO Implement this function
std::optional<Rectangle> fit_into_rectangle(const Polygon& polygon, float epsilon = k_default_epsilon) {
    return std::nullopt;
}

int main() {
    {
        // Case 1: a well formed rectangle
        //   *------*
        //   |      |
        //   |      |
        //   |      |
        //   *------*
        const Polygon polygon({{1, 1}, {6, 1}, {6, 4}, {1, 4}, {1, 1}});
        const auto rectangle = fit_into_rectangle(polygon);
        assert(rectangle);
        assert(almost_equal(*rectangle, Rectangle{{1, 1}, {6, 4}}));
    }

    {
        // Case 2: a polygon with redundant points
        //   *--*---*
        //   |      |
        //   |      *
        //   |      |
        //   *------*
        const Polygon polygon({{1,1},{6,1},{6,3},{6,5},{3,5},{1,5},{1,1}});
        const auto rectangle = fit_into_rectangle(polygon);
        assert(rectangle);
        assert(almost_equal(*rectangle, Rectangle{{1, 1}, {6, 5}}));
    }

    {
        // Case 3: a polygon with a diagonal edge
        //   *------*
        //   |       `
        //   |        `
        //   |         `
        //   *----------*
        const Polygon polygon({{1,1},{10,1},{6,5},{1,5},{1,1}});
        const auto rectangle = fit_into_rectangle(polygon);
        assert(not rectangle);
    }

    {
        // Case 4: a polygon with axis-aligned edges, but non-rectangular shape
        //   *------*
        //   |      |
        //   |      *---*
        //   |          |
        //   *----------*
        const Polygon polygon({{1,1},{10,1},{10,3},{6,3},{6,5},{1,5},{1,1}});
        const auto rectangle = fit_into_rectangle(polygon);
        assert(not rectangle);
    }

    {
        // Case 5: a polygon with slightly perturbed points, this is bread-and-butter in computational geometry
        //   *------*
        //   |      |
        //   |      |
        //   |      |
        //   *------~
        const Polygon polygon({{1,1},{6,1.00001},{6,4},{1,4},{1,1}});
        const auto rectangle = fit_into_rectangle(polygon);
        assert(rectangle);
        assert(almost_equal(*rectangle, Rectangle{{1, 1}, {6, 4}}));
    }
}
