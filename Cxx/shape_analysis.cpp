// -*- C++ -*-
#ifndef CNC_H
#define CNC_H

/*
  Context
  =======
  This question is based on a real problem that we had to solve in production. There was a computationally
  expensive algorithm implemented for generic polygons; however we have noticed that in the majority of
  cases the polygon that we were passing to the algorithm was a rectangle, and for rectangles the
  implementation of the algorithm was much faster.
  Task
  ====
  Implement a function that determines whether a given `Polygon` represents an axis-aligned rectangle, and
  if so, returns a `Rectangle` which is equivalent.
  You may assume:
  - `Polygon` is a counter-clockwise oriented collection of points. This means the inside of the polygon
  would be on your left if you walked around the boundary following the points in the order provided
  - `Polygon`, if not empty, is guaranteed to be cyclic, that is `polygon.front() == polygon.back()`
  The `Polygon` may have been generated by other algorithms which suffer numerical instability problems so
  your implementation should aim to be robust to degenerate cases. Example degenerate cases which should
  be handled include:
  - Points lying on the straight edge connecting another pair of points a.k.a. redundant points
  - Polygons with points slightly perturbed from exact rectangles should still convert to rectangles
  Instructions
  ============
  - Write one or two paragraphs about the chosen approach and document key assumptions you make regarding
  the input and the expected behaviour of your implementation
  - Preserve the API of the `fit_into_rectangle` function (so we can easily run it through a test suite)
  - Submit your solution as a single .cpp file and provide the compilation command used to build it.
  If you have been asked to submit your solution using codeinterview.io, you can make sure that your
  solution builds and passes the tests by pressing the "Run" button at the bottom of the page
  - Please give an approximate time taken to solve the question
*/


#include <cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <optional>
#include <limits>


constexpr float k_default_epsilon = .0001f;

bool almost_equal(float a, float b, float epsilon = k_default_epsilon) {
  return std::abs(a - b) <= epsilon;
}

struct Point {
  float x;
  float y;

  auto operator+(const Point& rhs) { return Point{this->x + rhs.x, this->y + rhs.y}; }
  auto operator-(const Point& rhs) { return Point{this->x - rhs.x, this->y - rhs.y}; }
  auto operator*(const Point& rhs) { return Point{this->x * rhs.x, this->y * rhs.y}; }
  auto operator/(const Point& rhs) { return Point{this->x / rhs.x, this->y / rhs.y}; }

  friend bool operator==(const Point& lhs, const Point& rhs) {
    return lhs.x == rhs.x && lhs.y == rhs.y;
  }
  friend std::ostream& operator<<(std::ostream& out, const Point& point) {
    return out << "(" << point.x << "," << point.y << ")";
  }
};

bool almost_equal(const Point& a, const Point& b, float epsilon = k_default_epsilon) {
  return almost_equal(a.x, b.x, epsilon) && almost_equal(a.y, b.y, epsilon);
}

using Polygon = std::vector<Point>;

struct Rectangle {
  Point bottom_left;
  Point top_right;
  friend std::ostream& operator<<(std::ostream& out, const Rectangle& rectangle) {
    return out << "Rectangle(" << rectangle.bottom_left << "," << rectangle.top_right << ")";
  }
};

bool almost_equal(const Rectangle& a, const Rectangle& b, float epsilon = k_default_epsilon) {
  return almost_equal(a.bottom_left, b.bottom_left) && almost_equal(a.top_right, b.top_right);
}


/*
  Approach

  A well formed, axis aligned, rectangle is sufficiently defined by lower and upper bound coordinates.
  From this information its centroid can be trivially and precisely computed. This provides a single reference
  point by which a candidate rectangle can be checked against. All points must be visited in order to compute the
  reference centroid.

  If a candidate rectangle is well formed and axis aligned, its centroid ought to be very close to the reference
  centroid, above. In order to compute a candidate centroid, a sufficiently generic technique must be employed.
  Here, the formula for the centroid of a non-self-intersecting closed polygon is employed, since it can accommodate
  the kind of candidate data expected. To compute the polygon centroid, all points must be visited.

  In order to optimise the function, early failure should be detected. This can been done in two ways:
  1) check that each edge is aligned to either the x or y axis,
  2) check that one edge followed by the next edge does not form a concave corner.
*/
std::optional<Rectangle> fit_into_rectangle(const Polygon& polygon, float epsilon = k_default_epsilon)
{
  auto success = true;

  auto constexpr large = std::numeric_limits<float>::max();
  int const n = polygon.size();

  Point lb = {large, large};
  Point ub = {-large, -large};
  Point db = {0, 0};

  Point xc = {0, 0};
  float area = 0;

  float x0 = polygon[0].x;
  float y0 = polygon[0].y;
  float dx0 = 0;
  float dy0 = 0;

  for (int i = 1; i != n; ++i)
  {
    // cache this and the next point
    auto const x = polygon[i].x;
    auto const y = polygon[i].y;
    auto const dx = x - x0;
    auto const dy = y - y0;

    // check axis alignment
    {
      auto const mag = std::hypot(dx, dy);
      success &=
        almost_equal(mag, std::abs(dx), epsilon) ||
        almost_equal(mag, std::abs(dy), epsilon);
      if (!success) return std::nullopt;
    }

    // check for concavities
    if (i > 1)
    {
      success &= !(dy0 > 0 && dx > 0);
      success &= !(dy0 < 0 && dx < 0);
      success &= !(dx0 < 0 && dy > 0);
      success &= !(dx0 > 0 && dy < 0);
      if (!success) return std::nullopt;
    }

    // lower and upper bounds, and delta
    lb.x = std::min(lb.x, x);
    lb.y = std::min(lb.y, y);
    ub.x = std::max(ub.x, x);
    ub.y = std::max(ub.y, y);
    db = ub - lb;

    // polygon centroid (partial)
    {
      auto const dxy = (x0*y - x*y0);
      xc.x = xc.x + (x0 + x)*dxy;
      xc.y = xc.y + (y0 + y)*dxy;
      area += dxy;
    }

    // update previous point and edge values
    x0 = x;
    y0 = y;
    dx0 = dx;
    dy0 = dy;
  }

  // polygon centroid (final)
  area /= 2;
  xc.x /= (6 * area);
  xc.y /= (6 * area);

  // candidate centroid based on computed bounds
  auto const xc_b = lb + db / Point{2.f, 2.f};

  // test polygon centroid against bounds centroid
  success &= almost_equal(xc, xc_b, epsilon);

  if (success) return Rectangle{lb, ub};

  return std::nullopt;
}


int main() {
  {
    // Case 1: a well formed rectangle
    //   *------*
    //   |      |
    //   |      |
    //   |      |
    //   *------*
    const Polygon polygon({{1, 1}, {6, 1}, {6, 4}, {1, 4}, {1, 1}});
    const auto rectangle = fit_into_rectangle(polygon);
    assert(rectangle);
    assert(almost_equal(*rectangle, Rectangle{{1, 1}, {6, 4}}));
  }

  {
    // Case 2: a polygon with redundant points
    //   *--*---*
    //   |      |
    //   |      *
    //   |      |
    //   *------*
    const Polygon polygon({{1,1},{6,1},{6,3},{6,5},{3,5},{1,5},{1,1}});
    const auto rectangle = fit_into_rectangle(polygon);
    assert(rectangle);
    assert(almost_equal(*rectangle, Rectangle{{1, 1}, {6, 5}}));
  }

  {
    // Case 3: a polygon with a diagonal edge
    //   *------*
    //   |       `
    //   |        `
    //   |         `
    //   *----------*
    const Polygon polygon({{1,1},{10,1},{6,5},{1,5},{1,1}});
    const auto rectangle = fit_into_rectangle(polygon);
    assert(!rectangle);
  }

  {
    // Case 4: a polygon with axis-aligned edges, but non-rectangular shape
    //   *------*
    //   |      |
    //   |      *---*
    //   |          |
    //   *----------*
    const Polygon polygon({{1,1},{10,1},{10,3},{6,3},{6,5},{1,5},{1,1}});
    const auto rectangle = fit_into_rectangle(polygon);
    assert(!rectangle);
  }

  {
    // Case 5: a polygon with slightly perturbed points, this is bread-and-butter in computational geometry
    //   *------*
    //   |      |
    //   |      |
    //   |      |
    //   *------~
    const Polygon polygon({{1,1},{6,1.00001},{6,4},{1,4},{1,1}});
    const auto rectangle = fit_into_rectangle(polygon);
    assert(rectangle);
    assert(almost_equal(*rectangle, Rectangle{{1, 1}, {6, 4}}));
  }
}

#endif // include guard
